/*
void complete_graph()
{
    std::vector<double> points;
    std::vector<unsigned> faces;

    // std::string input_file = "../input/small_terrain.off";
    std::string input_file = "../input/Sichuan2007.off";
    geodesic::read_mesh_from_file(&input_file[0], points, faces);
    geodesic::Mesh mesh;
    mesh.initialize_mesh_data(points, faces);
    geodesic::GeodesicAlgorithmExact algorithm(&mesh);

    std::vector<int> poi_list;
    int poi_num;
    std::ifstream input("../input/poilist2.txt", std::ios::in);
    input >> poi_num;
    poi_list.resize(poi_num);
    for (int i = 0; i < poi_num; i++)
    {
        input >> poi_list[i];
    }

    double const distance_limit = geodesic::GEODESIC_INF;
    std::vector<std::vector<double>> pairwise_distance_poi_to_poi(poi_num, std::vector<double>(poi_num, 0));
    std::vector<geodesic::SurfacePoint> one_source_poi_list;
    std::vector<geodesic::SurfacePoint> destinations_poi_list;

    for (int i = 0; i < poi_num; i++)
    {
        one_source_poi_list.clear();
        destinations_poi_list.clear();
        one_source_poi_list.push_back(geodesic::SurfacePoint(&mesh.vertices()[poi_list[i]]));

        for (int j = i; j < poi_num; j++)
        {
            destinations_poi_list.push_back(geodesic::SurfacePoint(&mesh.vertices()[poi_list[j]]));
            // std::cout << poi_list[j] << std::endl;
        }

        algorithm.propagate(one_source_poi_list, distance_limit, &destinations_poi_list);

        for (int j = i; j < poi_num; j++)
        {
            double distance;
            algorithm.best_source(destinations_poi_list[j - i], distance);
            pairwise_distance_poi_to_poi[i][j] = distance;
            // std::cout << "i " << i << ", j " << j << " - " << distance << std::endl;
        }
        for (int j = 0; j < poi_num; j++)
        {
            std::cout << "i " << i << ", j " << j << " - " << pairwise_distance_poi_to_poi[i][j] << std::endl;
        }
    }
}
*/



/*
void pre_post_terrain_complete_graph(std::string pre_input_file, std::string pre_input_poi,
                                     std::string post_input_file, std::string post_input_poi,
                                     std::vector<std::vector<double>> &pairwise_distance_poi_to_poi)
{
    // pre terrain
    std::vector<double> pre_points;
    std::vector<unsigned> pre_faces;

    geodesic::read_mesh_from_file(&pre_input_file[0], pre_points, pre_faces);
    geodesic::Mesh pre_mesh;
    pre_mesh.initialize_mesh_data(pre_points, pre_faces);
    geodesic::GeodesicAlgorithmExact pre_algorithm(&pre_mesh);

    std::vector<int> pre_poi_list;
    int poi_num;
    std::ifstream pre_input(&pre_input_poi[0], std::ios::in);
    pre_input >> poi_num;
    pre_poi_list.resize(poi_num);
    for (int i = 0; i < poi_num; i++)
    {
        pre_input >> pre_poi_list[i];
    }

    // std::vector<std::vector<int>> propagate_cover_face_index_list;
    // std::vector<int> one_poi_propagate_cover_face_index_list;
    // propagate_cover_face_index_list.clear();
    // one_poi_propagate_cover_face_index_list.clear();

    std::vector<std::vector<std::vector<int>>> pre_face_sequence_index_list;
    std::vector<std::vector<int>> one_poi_to_other_poi_pre_face_sequence_index_list;
    std::vector<int> one_poi_pre_face_sequence_index_list;
    pre_face_sequence_index_list.clear();

    double const distance_limit = geodesic::GEODESIC_INF;
    // std::vector<std::vector<double>> pairwise_distance_poi_to_poi(poi_num, std::vector<double>(poi_num, 0));
    // std::vector<std::vector<double>> pairwise_distance_poi_to_poi;
    pairwise_distance_poi_to_poi.clear();
    // std::vector<std::vector<bool>> pairwise_distance_poi_to_poi_changed(poi_num, std::vector<bool>(poi_num, false));
    std::vector<std::vector<bool>> pairwise_distance_poi_to_poi_changed;
    pairwise_distance_poi_to_poi_changed.clear();
    std::vector<std::vector<double>> pairwise_distance_poi_to_vertex(poi_num, std::vector<double>(pre_mesh.vertices().size(), 0));
    std::vector<geodesic::SurfacePoint> one_source_poi_list;
    std::vector<geodesic::SurfacePoint> destinations_poi_list;
    std::vector<geodesic::SurfacePoint> destinations_vertex_list;

    auto start_preprocessing_time = std::chrono::high_resolution_clock::now();

    // calculate the pairwise geodesic distance on pre terrain
    for (int i = 0; i < poi_num; i++)
    {
        std::vector<double> current_poi_to_other_poi_distance;
        current_poi_to_other_poi_distance.clear();
        std::vector<bool> current_poi_to_other_poi_distance_changed;
        current_poi_to_other_poi_distance_changed.clear();
        one_source_poi_list.clear();
        destinations_poi_list.clear();
        destinations_vertex_list.clear();
        one_poi_to_other_poi_pre_face_sequence_index_list.clear();
        one_poi_pre_face_sequence_index_list.clear();
        one_source_poi_list.push_back(geodesic::SurfacePoint(&pre_mesh.vertices()[pre_poi_list[i]]));

        for (int j = i; j < poi_num; j++)
        {
            destinations_poi_list.push_back(geodesic::SurfacePoint(&pre_mesh.vertices()[pre_poi_list[j]]));
            // std::cout << poi_list[j] << std::endl;
        }

        for (int j = 0; j < pre_mesh.vertices().size(); j++)
        {
            destinations_vertex_list.push_back(geodesic::SurfacePoint(&pre_mesh.vertices()[j]));
        }

        pre_algorithm.propagate(one_source_poi_list, distance_limit, &destinations_vertex_list);

        for (int j = 0; j < i; j++)
        {
            one_poi_to_other_poi_pre_face_sequence_index_list.push_back(one_poi_pre_face_sequence_index_list);
            // one_poi_to_other_poi_pre_face_sequence_index_list.push_back(pre_face_sequence_index_list[j][i]);
        }

        for (int j = i; j < poi_num; j++)
        {
            std::vector<geodesic::SurfacePoint> path;
            pre_algorithm.trace_back(destinations_poi_list[j - i], path);
            current_poi_to_other_poi_distance.push_back(length(path));
            current_poi_to_other_poi_distance_changed.push_back(false);
            // pairwise_distance_poi_to_poi[i][j] = length(path);
            // std::cout << path.size() << std::endl;
            get_face_sequence(&pre_mesh, path, one_poi_pre_face_sequence_index_list);
            // for (int k = 0; k < one_poi_pre_face_sequence_index_list.size(); k++)
            // {
            //     std::cout << one_poi_pre_face_sequence_index_list[k] << " ";
            // }
            // std::cout << std::endl;
            one_poi_to_other_poi_pre_face_sequence_index_list.push_back(one_poi_pre_face_sequence_index_list);

            // std::cout << "i " << i << ", j " << j << " - " << distance << std::endl;
        }
        pairwise_distance_poi_to_poi.push_back(current_poi_to_other_poi_distance);
        pairwise_distance_poi_to_poi_changed.push_back(current_poi_to_other_poi_distance_changed);
        pre_face_sequence_index_list.push_back(one_poi_to_other_poi_pre_face_sequence_index_list);
        // for (int j = 0; j < poi_num; j++)
        // {
        //     // std::cout << "i " << i << ", j " << j << ": ";
        //     for (int k = 0; k < pre_face_sequence_index_list[i][j].size(); k++)
        //     {
        //         std::cout << pre_face_sequence_index_list[i][j][k] << " ";
        //     }
        //     std::cout << std::endl;
        // }

        // for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
        // {
        //     std::cout << "i " << i << ", j " << j << " - " << pairwise_distance_poi_to_poi[i][j] << std::endl;
        // }
        for (int j = 0; j < pre_mesh.vertices().size(); j++)
        {
            double distance;
            pre_algorithm.best_source(destinations_vertex_list[j], distance);
            pairwise_distance_poi_to_vertex[i][j] = distance;
            // std::cout << "i " << i << ", j " << j << " - " << distance << std::endl;
        }
    }

    auto stop_preprocessing_time = std::chrono::high_resolution_clock::now();
    auto duration_preprocessing_time = std::chrono::duration_cast<std::chrono::milliseconds>(stop_preprocessing_time - start_preprocessing_time);
    double preprocessing_time = duration_preprocessing_time.count();
    std::cout << "Total preprocessing time: " << preprocessing_time << " ms" << std::endl;

    // post terrain
    std::vector<double> post_points;
    std::vector<unsigned> post_faces;

    geodesic::read_mesh_from_file(&post_input_file[0], post_points, post_faces);
    geodesic::Mesh post_mesh;
    post_mesh.initialize_mesh_data(post_points, post_faces);
    geodesic::GeodesicAlgorithmExact post_algorithm(&post_mesh);

    std::vector<int> post_poi_list;
    std::ifstream post_input(&post_input_poi[0], std::ios::in);
    post_input >> poi_num;
    post_poi_list.resize(poi_num);
    for (int i = 0; i < poi_num; i++)
    {
        post_input >> post_poi_list[i];
    }

    auto start_updating_time = std::chrono::high_resolution_clock::now();

    // auto start_change_detection_time = std::chrono::high_resolution_clock::now();

    // compare the pre and post terrain to detect changed face
    std::vector<int> changed_face_index_list;
    changed_face_index_list.clear();
    assert(pre_mesh.faces().size() == post_mesh.faces().size());
    for (int i = 0; i < pre_mesh.faces().size(); i++)
    {
        if (pre_mesh.faces()[i].adjacent_vertices()[0]->x() != post_mesh.faces()[i].adjacent_vertices()[0]->x() ||
            pre_mesh.faces()[i].adjacent_vertices()[0]->y() != post_mesh.faces()[i].adjacent_vertices()[0]->y() ||
            pre_mesh.faces()[i].adjacent_vertices()[0]->z() != post_mesh.faces()[i].adjacent_vertices()[0]->z() ||
            pre_mesh.faces()[i].adjacent_vertices()[1]->x() != post_mesh.faces()[i].adjacent_vertices()[1]->x() ||
            pre_mesh.faces()[i].adjacent_vertices()[1]->y() != post_mesh.faces()[i].adjacent_vertices()[1]->y() ||
            pre_mesh.faces()[i].adjacent_vertices()[1]->z() != post_mesh.faces()[i].adjacent_vertices()[1]->z() ||
            pre_mesh.faces()[i].adjacent_vertices()[2]->x() != post_mesh.faces()[i].adjacent_vertices()[2]->x() ||
            pre_mesh.faces()[i].adjacent_vertices()[2]->y() != post_mesh.faces()[i].adjacent_vertices()[2]->y() ||
            pre_mesh.faces()[i].adjacent_vertices()[2]->z() != post_mesh.faces()[i].adjacent_vertices()[2]->z())
        {
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[0]->x() << " " << post_mesh.faces()[i].adjacent_vertices()[0]->x() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[0]->y() << " " << post_mesh.faces()[i].adjacent_vertices()[0]->y() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[0]->z() << " " << post_mesh.faces()[i].adjacent_vertices()[0]->z() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[1]->x() << " " << post_mesh.faces()[i].adjacent_vertices()[1]->x() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[1]->y() << " " << post_mesh.faces()[i].adjacent_vertices()[1]->y() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[1]->z() << " " << post_mesh.faces()[i].adjacent_vertices()[1]->z() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[2]->x() << " " << post_mesh.faces()[i].adjacent_vertices()[2]->x() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[2]->y() << " " << post_mesh.faces()[i].adjacent_vertices()[2]->y() << std::endl;
            // std::cout << pre_mesh.faces()[i].adjacent_vertices()[2]->z() << " " << post_mesh.faces()[i].adjacent_vertices()[2]->z() << std::endl;
            changed_face_index_list.push_back(i);
            // std::cout << i << std::endl;
        }
    }
    // std::cout << changed_face_index_list.size() << std::endl;

    // compare the pre and post terrain to detect changed vertex
    std::vector<int> changed_vertex_index_list;
    changed_vertex_index_list.clear();
    assert(pre_mesh.vertices().size() == post_mesh.vertices().size());
    for (int i = 0; i < pre_mesh.vertices().size(); i++)
    {
        if (pre_mesh.vertices()[i].x() != post_mesh.vertices()[i].x() ||
            pre_mesh.vertices()[i].y() != post_mesh.vertices()[i].y() ||
            pre_mesh.vertices()[i].z() != post_mesh.vertices()[i].z())
        {
            changed_vertex_index_list.push_back(i);
        }
    }

    // stores the changed poi index such that (1) the index of poi changed, (2) this poi is in the changed area, (3) the path that connects this poi passes the changed area
    std::vector<int> changed_poi_index_list(poi_num, 0);

    // stores only the poi in the changed area (used in calculation the 2D distance between these pois and other pois)
    std::vector<int> poi_in_the_changed_area_index_list;
    poi_in_the_changed_area_index_list.clear();

    // for the pre and post list, the index of poi may change, but the actual vertex on the terrain that these two pois stand for are very close
    // if the poi for the pre and post list changed, then the value in this list becomes 1, which indicates changes
    for (int i = 0; i < poi_num; i++)
    {
        if (pre_poi_list[i] != post_poi_list[i])
        {
            changed_poi_index_list[i] = 1;
        }
    }

    // for the pre and post list, even if the index of poi not changes, if the poi is on the changed area, we also indicate it by 1 in the following list
    for (int i = 0; i < poi_num; i++)
    {
        if (changed_poi_index_list[i] == 1)
        {
            continue;
        }
        for (int j = 0; j < changed_face_index_list.size(); j++)
        {
            if (pre_poi_list[i] == post_poi_list[i] &&
                (pre_mesh.faces()[changed_face_index_list[j]].adjacent_vertices()[0]->id() == pre_poi_list[i] ||
                 pre_mesh.faces()[changed_face_index_list[j]].adjacent_vertices()[1]->id() == pre_poi_list[i] ||
                 pre_mesh.faces()[changed_face_index_list[j]].adjacent_vertices()[2]->id() == pre_poi_list[i]))
            {
                // std::cout << pre_poi_list[i] << std::endl;
                changed_poi_index_list[i] = 1;
                poi_in_the_changed_area_index_list.push_back(i);
                break;
            }
        }
    }

    // if two pois are not in the changed area, but the path passes the changed area, we also indicate the poi by 1
    // note that for a poi, if one of the path that connects this poi passes the changed area, then we need to run SSAD
    // for this poi again involves all the path connects to this poi
    for (int i = 0; i < poi_num; i++)
    {
        bool break_loop = false;
        if (changed_poi_index_list[i] == 1)
        {
            continue;
        }
        for (int j = i; j < poi_num; j++)
        {
            if (changed_poi_index_list[j] == 1)
            {
                continue;
            }
            for (int k = 0; k < pre_face_sequence_index_list[i][j].size(); k++)
            {
                for (int m = 0; m < changed_face_index_list.size(); m++)
                {
                    // std::cout << changed_face_index_list[m] << " " << pre_face_sequence_index_list[i][j][k] << std::endl;

                    if (changed_face_index_list[m] == pre_face_sequence_index_list[i][j][k])
                    {
                        changed_poi_index_list[i] = 1;
                        break_loop = true;
                        break;
                    }
                }
                if (break_loop)
                {
                    break;
                }
            }
            if (break_loop)
            {
                break;
            }
        }
    }

    // auto stop_change_detection_time = std::chrono::high_resolution_clock::now();
    // auto duration_change_detection_time = std::chrono::duration_cast<std::chrono::microseconds>(stop_change_detection_time - start_change_detection_time);
    // double change_detection_time = duration_change_detection_time.count();
    // std::cout << "Total change detection time: " << change_detection_time / 1000 << " ms" << std::endl;

    // update the pairwise geodesic distance on post terrain for changed poi
    for (int i = 0; i < poi_num; i++)
    {
        one_source_poi_list.clear();
        destinations_poi_list.clear();

        if (changed_poi_index_list[i] == 0)
        {
            continue;
        }

        one_source_poi_list.push_back(geodesic::SurfacePoint(&post_mesh.vertices()[post_poi_list[i]]));

        for (int j = 0; j < poi_num; j++)
        {
            if (changed_poi_index_list[j] == 1 && j < i)
            {
                continue;
            }
            destinations_poi_list.push_back(geodesic::SurfacePoint(&post_mesh.vertices()[post_poi_list[j]]));
            // std::cout << "i " << i << ", j " << j << ", j's x " << post_mesh.vertices()[post_poi_list[j]].x() << ", j's y " << post_mesh.vertices()[post_poi_list[j]].y() << ", j's z " << post_mesh.vertices()[post_poi_list[j]].z() << std::endl;
        }

        post_algorithm.propagate(one_source_poi_list, distance_limit, &destinations_poi_list);

        int index = 0;
        for (int j = 0; j < poi_num; j++)
        {
            if (changed_poi_index_list[j] == 1 && j < i)
            {
                index++;
                continue;
            }
            double distance;
            post_algorithm.best_source(destinations_poi_list[j - index], distance);

            // std::vector<geodesic::SurfacePoint> path;
            // post_algorithm.trace_back(destinations_poi_list[j - index], path);
            // std::cout << "i " << i << ", j " << j << ", j's x " << destinations_poi_list[j - index].x() << ", j's y " << destinations_poi_list[j - index].y() << ", j's z " << destinations_poi_list[j - index].z() << std::endl;

            if (i <= j)
            {
                // pairwise_distance_poi_to_poi[i][j] = length(path);
                pairwise_distance_poi_to_poi[i][j - i] = distance;
                pairwise_distance_poi_to_poi_changed[i][j - i] = true;
            }
            else
            {
                // pairwise_distance_poi_to_poi[j][i] = length(path);
                pairwise_distance_poi_to_poi[j][i - j] = distance;
                pairwise_distance_poi_to_poi_changed[j][i - j] = true;
            }
        }

        // for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
        // {
        //     std::cout << "i " << i << ", j " << j << " - " << pairwise_distance_poi_to_poi[i][j] << std::endl;
        // }
    }
    // for (int i = 0; i < poi_num; i++)
    // {
    //     for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
    //     {
    //         std::cout << "i " << i << ", j " << j << " - " << pairwise_distance_poi_to_poi[i][j] << std::endl;
    //     }
    // }

    // if two pois are not in the changed area, and the path doesn't pass the changed area, but one of pois is close to the
    // changed area, so we may need to update the new path with these two pois as endpoints on the new terrain, the following
    // is to check whether the original path is too close to the changed area or not, if so, we directly update the path
    // we also indicate this type of poi in changed_poi_index_list, but indicate it as 2 for clarification

    std::vector<double> euclidean_distance_of_poi_to_changed_area(poi_num, 0);
    std::vector<std::pair<double, int>> euclidean_distance_of_poi_to_changed_area_and_original_index;

    for (int i = 0; i < poi_num; i++)
    {
        if (changed_poi_index_list[i] == 1)
        {
            continue;
        }
        if (poi_in_the_changed_area_index_list.size() > 0)
        {
            for (int j = 0; j < poi_in_the_changed_area_index_list.size(); j++)
            {
                euclidean_distance_of_poi_to_changed_area[i] += euclidean_distance(post_mesh.vertices()[post_poi_list[i]].x(), post_mesh.vertices()[post_poi_list[i]].y(),
                                                                                   post_mesh.vertices()[poi_in_the_changed_area_index_list[j]].x(), post_mesh.vertices()[poi_in_the_changed_area_index_list[j]].y());
            }
        }
        else
        {
            euclidean_distance_of_poi_to_changed_area[i] = euclidean_distance(post_mesh.vertices()[post_poi_list[i]].x(), post_mesh.vertices()[post_poi_list[i]].y(),
                                                                              post_mesh.vertices()[changed_vertex_index_list[0]].x(), post_mesh.vertices()[changed_vertex_index_list[0]].y());
        }
        // std::cout << "euclidean_distance_of_poi_to_changed_area: " << euclidean_distance_of_poi_to_changed_area[i] << std::endl;
    }

    sort_min_to_max_and_get_original_index(euclidean_distance_of_poi_to_changed_area, euclidean_distance_of_poi_to_changed_area_and_original_index);
    assert(euclidean_distance_of_poi_to_changed_area.size() == euclidean_distance_of_poi_to_changed_area_and_original_index.size());

    for (int i = 0; i < euclidean_distance_of_poi_to_changed_area_and_original_index.size(); i++)
    {
        if (euclidean_distance_of_poi_to_changed_area_and_original_index[i].first == 0)
        {
            continue;
        }
        int current_poi_index = euclidean_distance_of_poi_to_changed_area_and_original_index[i].second;
        // std::cout << "euclidean_distance_of_poi_to_changed_area_and_original_index: " << euclidean_distance_of_poi_to_changed_area_and_original_index[i].first << ", index: " << current_poi_index << std::endl;

        assert(pairwise_distance_poi_to_poi[current_poi_index].size() == pairwise_distance_poi_to_poi_changed[current_poi_index].size());

        double max_distance = 0;
        for (int j = 0; j < euclidean_distance_of_poi_to_changed_area_and_original_index.size(); j++)
        {
            if (euclidean_distance_of_poi_to_changed_area_and_original_index[j].first == 0)
            {
                continue;
            }
            int checking_poi_index = euclidean_distance_of_poi_to_changed_area_and_original_index[j].second;

            if (current_poi_index <= checking_poi_index)
            {
                if (pairwise_distance_poi_to_poi_changed[current_poi_index][checking_poi_index - current_poi_index])
                {
                    continue;
                }
                max_distance = std::max(max_distance, pairwise_distance_poi_to_poi[current_poi_index][checking_poi_index - current_poi_index]);
            }
            else
            {
                if (pairwise_distance_poi_to_poi_changed[checking_poi_index][current_poi_index - checking_poi_index])
                {
                    continue;
                }
                max_distance = std::max(max_distance, pairwise_distance_poi_to_poi[checking_poi_index][current_poi_index - checking_poi_index]);
            }
        }
        // std::cout << max_distance << std::endl;

        // if the current poi is too close to the changed area, we need to run SSAD for this poi to update it path on the new terrain
        for (int k = 0; k < changed_vertex_index_list.size(); k++)
        {
            if (pairwise_distance_poi_to_vertex[current_poi_index][changed_vertex_index_list[k]] < max_distance / 2)
            {
                changed_poi_index_list[current_poi_index] = 2;

                std::vector<int> destinations_poi_index_list;
                destinations_poi_index_list.clear();
                one_source_poi_list.clear();
                destinations_poi_list.clear();
                one_source_poi_list.push_back(geodesic::SurfacePoint(&post_mesh.vertices()[post_poi_list[current_poi_index]]));

                for (int j = 0; j < euclidean_distance_of_poi_to_changed_area_and_original_index.size(); j++)
                {
                    int the_other_poi_index = euclidean_distance_of_poi_to_changed_area_and_original_index[j].second;

                    if ((current_poi_index <= the_other_poi_index && !pairwise_distance_poi_to_poi_changed[current_poi_index][the_other_poi_index - current_poi_index]) ||
                        (current_poi_index > the_other_poi_index && !pairwise_distance_poi_to_poi_changed[the_other_poi_index][current_poi_index - the_other_poi_index]))
                    {
                        destinations_poi_list.push_back(geodesic::SurfacePoint(&post_mesh.vertices()[post_poi_list[the_other_poi_index]]));
                        destinations_poi_index_list.push_back(the_other_poi_index);
                    }
                }
                post_algorithm.propagate(one_source_poi_list, distance_limit, &destinations_poi_list);

                assert(destinations_poi_list.size() == destinations_poi_index_list.size());
                for (int j = 0; j < destinations_poi_index_list.size(); j++)
                {
                    int the_other_poi_index = destinations_poi_index_list[j];

                    double distance;
                    post_algorithm.best_source(destinations_poi_list[j], distance);
                    // std::cout << "current_poi_index " << current_poi_index << ", the_other_poi_index " << the_other_poi_index << std::endl;

                    if (current_poi_index <= the_other_poi_index)
                    {
                        pairwise_distance_poi_to_poi[current_poi_index][the_other_poi_index - current_poi_index] = distance;
                        pairwise_distance_poi_to_poi_changed[current_poi_index][the_other_poi_index - current_poi_index] = true;
                    }
                    else
                    {
                        pairwise_distance_poi_to_poi[the_other_poi_index][current_poi_index - the_other_poi_index] = distance;
                        pairwise_distance_poi_to_poi_changed[the_other_poi_index][current_poi_index - the_other_poi_index] = true;
                    }
                }
                break;
            }
        }
    }

    auto stop_updating_time = std::chrono::high_resolution_clock::now();
    auto duration_updating_time = std::chrono::duration_cast<std::chrono::milliseconds>(stop_updating_time - start_updating_time);
    double updating_time = duration_updating_time.count();
    std::cout << "Total updating time: " << updating_time << " ms" << std::endl;

    // for (int i = 0; i < poi_num; i++)
    // {
    //     for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
    //     {
    //         std::cout << "i: " << i << " , j: " << j << " , distance: " << pairwise_distance_poi_to_poi[i][j] << " , changed: " << pairwise_distance_poi_to_poi_changed[i][j] << std::endl;
    //     }
    // }

    // for (int i = 0; i < changed_poi_index_list.size(); i++)
    // {
    //     std::cout << changed_poi_index_list[i] << std::endl;
    // }
}
*/


/*
void clustering_greedy_spanner(std::vector<std::vector<double>> pairwise_distance_poi_to_poi, double epsilon,
                               std::unordered_map<int, double> &pairwise_distance_poi_to_poi_greedy_spanner_map)
{
    std::vector<std::pair<double, std::pair<int, int>>> min_to_max_pairwise_distance_poi_to_poi;
    min_to_max_pairwise_distance_poi_to_poi.clear();

    // for (int i = 0; i < pairwise_distance_poi_to_poi.size(); i++)
    // {
    //     for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
    //     {
    //         std::cout << "i: " << i << " , j: " << j << " , distance: " << pairwise_distance_poi_to_poi[i][j] << std::endl;
    //     }
    // }

    for (int i = 0; i < pairwise_distance_poi_to_poi.size(); i++)
    {
        for (int j = 0; j < pairwise_distance_poi_to_poi[i].size(); j++)
        {
            if (j == 0)
            {
                continue;
            }
            min_to_max_pairwise_distance_poi_to_poi.push_back(std::make_pair(pairwise_distance_poi_to_poi[i][j], std::make_pair(i, i + j)));
        }
    }
    std::sort(min_to_max_pairwise_distance_poi_to_poi.begin(), min_to_max_pairwise_distance_poi_to_poi.end());

    for (int i = 0; i < min_to_max_pairwise_distance_poi_to_poi.size(); i++)
    {
        std::cout << "i: " << min_to_max_pairwise_distance_poi_to_poi[i].second.first << ", j: " << min_to_max_pairwise_distance_poi_to_poi[i].second.second << ", distance: " << min_to_max_pairwise_distance_poi_to_poi[i].first << std::endl;
    }
    double max_pairwise_distance = min_to_max_pairwise_distance_poi_to_poi[min_to_max_pairwise_distance_poi_to_poi.size() - 1].first;
    // std::cout << "max_pairwise_distance: " << max_pairwise_distance << std::endl;

    Graph graph(pairwise_distance_poi_to_poi.size());
    std::vector<std::pair<double, std::pair<int, int>>> added_edge_in_greedy_spanner;

    std::vector<std::vector<std::pair<double, std::pair<int, int>>>> distance_interval;
    std::vector<std::pair<double, std::pair<int, int>>> one_distance_interval;
    distance_interval.clear();
    one_distance_interval.clear();

    int interval_zero_item_num = 0;
    for (int i = 0; i < min_to_max_pairwise_distance_poi_to_poi.size(); i++)
    {
        if (min_to_max_pairwise_distance_poi_to_poi[i].first > 0 &&
            min_to_max_pairwise_distance_poi_to_poi[i].first <= max_pairwise_distance / pairwise_distance_poi_to_poi.size())
        {
            graph.add_edge_Dijkstra(min_to_max_pairwise_distance_poi_to_poi[i].second.first, min_to_max_pairwise_distance_poi_to_poi[i].second.second, min_to_max_pairwise_distance_poi_to_poi[i].first);
            added_edge_in_greedy_spanner.push_back(min_to_max_pairwise_distance_poi_to_poi[i]);
            one_distance_interval.push_back(min_to_max_pairwise_distance_poi_to_poi[i]);
            interval_zero_item_num++;
        }
        else
        {
            break;
        }
    }
    distance_interval.push_back(one_distance_interval);

    int interval_index = 1;
    one_distance_interval.clear();

    // std::cout << "interval_zero_item_num: " << interval_zero_item_num << std::endl;

    for (int i = interval_zero_item_num; i < min_to_max_pairwise_distance_poi_to_poi.size(); i++)
    {
        if (min_to_max_pairwise_distance_poi_to_poi[i].first > pow(2, (interval_index - 1)) * max_pairwise_distance / pairwise_distance_poi_to_poi.size() &&
            min_to_max_pairwise_distance_poi_to_poi[i].first <= pow(2, interval_index) * max_pairwise_distance / pairwise_distance_poi_to_poi.size())
        {
            one_distance_interval.push_back(min_to_max_pairwise_distance_poi_to_poi[i]);
            // std::cout << "i: " << i << ", distance: " << min_to_max_pairwise_distance_poi_to_poi[i].first << std::endl;
        }
        else
        {
            distance_interval.push_back(one_distance_interval);
            interval_index++;
            one_distance_interval.clear();
            one_distance_interval.push_back(min_to_max_pairwise_distance_poi_to_poi[i]);
        }
    }
    distance_interval.push_back(one_distance_interval);

    // for (int i = 0; i < distance_interval.size(); i++)
    // {
    //     for (int j = 0; j < distance_interval[i].size(); j++)
    //     {
    //         std::cout << "i: " << i << ", interval distance: " << distance_interval[i][j].first << std::endl;
    //     }
    // }

    double W = max_pairwise_distance / pairwise_distance_poi_to_poi.size();
    double delta = 1 / 2 * ((pow((epsilon + 1), 0.5) - 1) / (pow((epsilon + 1), 0.5) + 3));

    for (int k = 1; k < ceil(log2(pairwise_distance_poi_to_poi.size())); k++)
    {
        // cluster graph
        std::set<int> unprocessed_poi;
        std::set<int> cannot_be_center_poi;
        unprocessed_poi.clear();
        cannot_be_center_poi.clear();

        for (int i = 0; i < pairwise_distance_poi_to_poi.size(); i++)
        {
            unprocessed_poi.insert(i);
            cannot_be_center_poi.insert(i);
        }

        std::unordered_map<int, std::vector<std::pair<int, double>>> centers;
        std::unordered_map<int, std::vector<std::pair<int, double>>> non_centers;
        centers.clear();
        non_centers.clear();

        auto ite = unprocessed_poi.begin();
        while (ite != unprocessed_poi.end())
        {
            // std::vector<std::pair<int, double>> center_coveres_poi;
            // std::vector<std::pair<int, double>> non_center_covered_by_poi;
            // center_coveres_poi.clear();
            // non_center_covered_by_poi.clear();

            int current_index = *ite;
            std::vector<double> current_poi_to_other_poi_distance_greedy_spanner(pairwise_distance_poi_to_poi.size(), INF);
            graph.shortest_path_Dijkstra(current_index, current_poi_to_other_poi_distance_greedy_spanner, delta * W);
            unprocessed_poi.erase(ite);
            cannot_be_center_poi.erase(ite);

            auto ite2 = cannot_be_center_poi.begin();
            while (ite2 != cannot_be_center_poi.end())
            {
                if (current_poi_to_other_poi_distance_greedy_spanner[*ite2] < INF &&
                    current_poi_to_other_poi_distance_greedy_spanner[*ite2] > 0)
                {
                    centers[current_index].push_back(std::make_pair(*ite2, current_poi_to_other_poi_distance_greedy_spanner[*ite2]));
                    non_centers[*ite2].push_back(std::make_pair(current_index, current_poi_to_other_poi_distance_greedy_spanner[*ite2]));
                    if (unprocessed_poi.count(*ite2))
                    {
                        unprocessed_poi.erase(ite2);
                    }
                }
                else
                {
                    ite2++;
                }
            }
        }

        // calculate inter-cluster edges of first type
        std::unordered_map<int, double> pairwise_distance_center_to_center;

        for (auto ite3 = centers.begin(); ite3 != centers.end(); ite3++)
        {
            std::vector<double> current_center_to_other_center_distance_greedy_spanner(centers.size(), INF);
            graph.shortest_path_Dijkstra(ite3->first, current_center_to_other_center_distance_greedy_spanner, W);
            for (auto ite4 = ite3; ite4 != centers.end(); ite4++)
            {
                if (current_center_to_other_center_distance_greedy_spanner[ite4->first] < INF &&
                    current_center_to_other_center_distance_greedy_spanner[ite4->first] > 0)
                {
                    int i_j;
                    hash_function_two_keys_to_one_key(centers.size(), ite3->first, ite4->first, i_j);
                    pairwise_distance_center_to_center[i_j] = current_center_to_other_center_distance_greedy_spanner[ite4->first];
                }
            }
        }

        // calculate inter-cluster edges of second type
        for (int i = 0; i < added_edge_in_greedy_spanner.size(); i++)
        {
            int one_endpoint_index = added_edge_in_greedy_spanner[i].second.first;
            int another_endpoint_index = added_edge_in_greedy_spanner[i].second.second;

            // if both two endpoints of an edge is the center
            if (centers.count(one_endpoint_index) != 0 && centers.count(another_endpoint_index) != 0)
            {
                int i_j;
                if (one_endpoint_index > another_endpoint_index)
                {
                    int temp = another_endpoint_index;
                    another_endpoint_index = one_endpoint_index;
                    one_endpoint_index = temp;
                }
                hash_function_two_keys_to_one_key(centers.size(), one_endpoint_index, another_endpoint_index, i_j);
                if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                    (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > added_edge_in_greedy_spanner[i].first))
                {
                    pairwise_distance_center_to_center[i_j] = added_edge_in_greedy_spanner[i].first;
                }
            }
            else if (centers.count(one_endpoint_index) == 0 && centers.count(another_endpoint_index) != 0)
            {
                for (auto ite = non_centers[one_endpoint_index].begin(); ite != non_centers[one_endpoint_index].end(); ite++)
                {
                    int one_non_center_endpoint_center_index = ite->first;
                    double one_non_center_endpoint_to_center_distance = ite->second;

                    int i_j;
                    if (one_non_center_endpoint_center_index > another_endpoint_index)
                    {
                        int temp = another_endpoint_index;
                        another_endpoint_index = one_non_center_endpoint_center_index;
                        one_non_center_endpoint_center_index = temp;
                    }
                    hash_function_two_keys_to_one_key(centers.size(), one_non_center_endpoint_center_index, another_endpoint_index, i_j);
                    if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                        (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > added_edge_in_greedy_spanner[i].first + one_non_center_endpoint_to_center_distance))
                    {
                        pairwise_distance_center_to_center[i_j] = added_edge_in_greedy_spanner[i].first + one_non_center_endpoint_to_center_distance;
                    }
                }
            }
            else if (centers.count(one_endpoint_index) != 0 && centers.count(another_endpoint_index) == 0)
            {
                for (auto ite = non_centers[another_endpoint_index].begin(); ite != non_centers[another_endpoint_index].end(); ite++)
                {
                    int another_non_center_endpoint_center_index = ite->first;
                    double another_non_center_endpoint_to_center_distance = ite->second;

                    int i_j;
                    if (one_endpoint_index > another_non_center_endpoint_center_index)
                    {
                        int temp = another_non_center_endpoint_center_index;
                        another_non_center_endpoint_center_index = one_endpoint_index;
                        one_endpoint_index = temp;
                    }
                    hash_function_two_keys_to_one_key(centers.size(), one_endpoint_index, another_non_center_endpoint_center_index, i_j);
                    if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                        (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > added_edge_in_greedy_spanner[i].first + another_non_center_endpoint_to_center_distance))
                    {
                        pairwise_distance_center_to_center[i_j] = added_edge_in_greedy_spanner[i].first + another_non_center_endpoint_to_center_distance;
                    }
                }
            }
            else
            {
                for (auto ite = non_centers[one_endpoint_index].begin(); ite != non_centers[one_endpoint_index].end(); ite++)
                {
                    for (auto ite2 = non_centers[another_endpoint_index].begin(); ite2 != non_centers[another_endpoint_index].end(); ite2++)
                    {
                        int one_non_center_endpoint_center_index = ite->first;
                        double one_non_center_endpoint_to_center_distance = ite->second;

                        int another_non_center_endpoint_center_index = ite2->first;
                        double another_non_center_endpoint_to_center_distance = ite2->second;

                        int i_j;
                        if (one_non_center_endpoint_center_index > another_non_center_endpoint_center_index)
                        {
                            int temp = another_non_center_endpoint_center_index;
                            another_non_center_endpoint_center_index = one_non_center_endpoint_center_index;
                            one_non_center_endpoint_center_index = temp;
                        }
                        hash_function_two_keys_to_one_key(centers.size(), one_non_center_endpoint_center_index, another_non_center_endpoint_center_index, i_j);
                        if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                            (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > added_edge_in_greedy_spanner[i].first + one_non_center_endpoint_to_center_distance + another_non_center_endpoint_to_center_distance))
                        {
                            pairwise_distance_center_to_center[i_j] = added_edge_in_greedy_spanner[i].first + one_non_center_endpoint_to_center_distance + another_non_center_endpoint_to_center_distance;
                        }
                    }
                }
            }
        }

        // for each edge in E_i
        for (int i = 0; i < distance_interval[k].size(); i++)
        {

            int one_endpoint_index = distance_interval[k][i].second.first;
            int another_endpoint_index = distance_interval[k][i].second.second;

            // if both two endpoints of an edge is the center
            if (centers.count(one_endpoint_index) != 0 && centers.count(another_endpoint_index) != 0)
            {
                int i_j;
                if (one_endpoint_index > another_endpoint_index)
                {
                    int temp = another_endpoint_index;
                    another_endpoint_index = one_endpoint_index;
                    one_endpoint_index = temp;
                }
                hash_function_two_keys_to_one_key(centers.size(), one_endpoint_index, another_endpoint_index, i_j);
                std::cout << "==both center==" << std::endl;
                if (pairwise_distance_center_to_center.count(i_j) == 0)
                {
                    std::cout << "center i: " << one_endpoint_index << ", center j: " << another_endpoint_index << ", distance_on_cluster_graph: " << INF << std::endl;
                }
                else
                {
                    std::cout << "center i: " << one_endpoint_index << ", center j: " << another_endpoint_index << ", distance_on_cluster_graph: " << pairwise_distance_center_to_center[i_j] << std::endl;
                }

                if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                    (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > (1 + epsilon) * distance_interval[k][i].first))
                {
                    std::cout << "^^^ added" << std::endl;
                    graph.add_edge_Dijkstra(one_endpoint_index, another_endpoint_index, min_to_max_pairwise_distance_poi_to_poi[i].first);
                }
            }
            else if (centers.count(one_endpoint_index) == 0 && centers.count(another_endpoint_index) != 0)
            {
                for (auto ite = non_centers[one_endpoint_index].begin(); ite != non_centers[one_endpoint_index].end(); ite++)
                {
                    int one_non_center_endpoint_center_index = ite->first;
                    double one_non_center_endpoint_to_center_distance = ite->second;

                    int i_j;
                    if (one_non_center_endpoint_center_index > another_endpoint_index)
                    {
                        int temp = another_endpoint_index;
                        another_endpoint_index = one_non_center_endpoint_center_index;
                        one_non_center_endpoint_center_index = temp;
                    }
                    hash_function_two_keys_to_one_key(centers.size(), one_non_center_endpoint_center_index, another_endpoint_index, i_j);
                    if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                        (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > distance_interval[k][i].first + one_non_center_endpoint_to_center_distance))
                    {
                        pairwise_distance_center_to_center[i_j] = distance_interval[k][i].first + one_non_center_endpoint_to_center_distance;
                    }
                }
            }
            else if (centers.count(one_endpoint_index) != 0 && centers.count(another_endpoint_index) == 0)
            {
                for (auto ite = non_centers[another_endpoint_index].begin(); ite != non_centers[another_endpoint_index].end(); ite++)
                {
                    int another_non_center_endpoint_center_index = ite->first;
                    double another_non_center_endpoint_to_center_distance = ite->second;

                    int i_j;
                    if (one_endpoint_index > another_non_center_endpoint_center_index)
                    {
                        int temp = another_non_center_endpoint_center_index;
                        another_non_center_endpoint_center_index = one_endpoint_index;
                        one_endpoint_index = temp;
                    }
                    hash_function_two_keys_to_one_key(centers.size(), one_endpoint_index, another_non_center_endpoint_center_index, i_j);
                    if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                        (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > distance_interval[k][i].first + another_non_center_endpoint_to_center_distance))
                    {
                        pairwise_distance_center_to_center[i_j] = distance_interval[k][i].first + another_non_center_endpoint_to_center_distance;
                    }
                }
            }
            else
            {
                for (auto ite = non_centers[one_endpoint_index].begin(); ite != non_centers[one_endpoint_index].end(); ite++)
                {
                    for (auto ite2 = non_centers[another_endpoint_index].begin(); ite2 != non_centers[another_endpoint_index].end(); ite2++)
                    {
                        int one_non_center_endpoint_center_index = ite->first;
                        double one_non_center_endpoint_to_center_distance = ite->second;

                        int another_non_center_endpoint_center_index = ite2->first;
                        double another_non_center_endpoint_to_center_distance = ite2->second;

                        int i_j;
                        if (one_non_center_endpoint_center_index > another_non_center_endpoint_center_index)
                        {
                            int temp = another_non_center_endpoint_center_index;
                            another_non_center_endpoint_center_index = one_non_center_endpoint_center_index;
                            one_non_center_endpoint_center_index = temp;
                        }
                        hash_function_two_keys_to_one_key(centers.size(), one_non_center_endpoint_center_index, another_non_center_endpoint_center_index, i_j);
                        if (pairwise_distance_center_to_center.count(i_j) == 0 ||
                            (pairwise_distance_center_to_center.count(i_j) != 0 && pairwise_distance_center_to_center[i_j] > distance_interval[k][i].first + one_non_center_endpoint_to_center_distance + another_non_center_endpoint_to_center_distance))
                        {
                            pairwise_distance_center_to_center[i_j] = distance_interval[k][i].first + one_non_center_endpoint_to_center_distance + another_non_center_endpoint_to_center_distance;
                        }
                    }
                }
            }

            std::vector<double> current_poi_to_other_poi_distance_greedy_spanner(pairwise_distance_poi_to_poi.size(), INF);
            graph.shortest_path_Dijkstra(min_to_max_pairwise_distance_poi_to_poi[i].second.first, current_poi_to_other_poi_distance_greedy_spanner, INF);
            double distance_on_graph = current_poi_to_other_poi_distance_greedy_spanner[min_to_max_pairwise_distance_poi_to_poi[i].second.second];
            std::cout << "i: " << min_to_max_pairwise_distance_poi_to_poi[i].second.first << ", j: " << min_to_max_pairwise_distance_poi_to_poi[i].second.second << ", real distance: " << min_to_max_pairwise_distance_poi_to_poi[i].first << ", distance_on_graph: " << distance_on_graph << std::endl;

            if (distance_on_graph > (1 + epsilon) * min_to_max_pairwise_distance_poi_to_poi[i].first)
            {
                std::cout << "^^^ added" << std::endl;
                graph.add_edge_Dijkstra(min_to_max_pairwise_distance_poi_to_poi[i].second.first, min_to_max_pairwise_distance_poi_to_poi[i].second.second, min_to_max_pairwise_distance_poi_to_poi[i].first);
            }
        }
        W = 2 * W;
    }

    for (int i = 0; i < pairwise_distance_poi_to_poi.size(); i++)
    {
        std::vector<double> current_poi_to_other_poi_distance_greedy_spanner(pairwise_distance_poi_to_poi.size(), INF);
        graph.shortest_path_Dijkstra(i, current_poi_to_other_poi_distance_greedy_spanner, INF);

        // for (int j = 0; j < current_poi_to_other_poi_distance_greedy_spanner.size(); j++)
        // {
        //     std::cout << "$$   i: " << i << ", j: " << j << ", approximate distance: " << current_poi_to_other_poi_distance_greedy_spanner[j] << std::endl;
        // }

        for (int j = i; j < pairwise_distance_poi_to_poi.size(); j++)
        {
            int i_j;
            hash_function_two_keys_to_one_key(pairwise_distance_poi_to_poi.size(), i, j, i_j);
            // pairwise_distance_poi_to_poi_greedy_spanner_map.insert(std::pair<int, double>(i_j, current_poi_to_other_poi_distance_greedy_spanner[j]));
            pairwise_distance_poi_to_poi_greedy_spanner_map[i_j] = current_poi_to_other_poi_distance_greedy_spanner[j];

            // std::cout << "i: " << i << ", j: " << j << ", approximate distance: " << current_poi_to_other_poi_distance_greedy_spanner[j] << std::endl;
        }
    }
}
*/


/*
    void UE_N1(std::string pre_input_file, std::string pre_input_poi,
            std::string post_input_file, std::string post_input_poi)
    {
        std::vector<std::vector<double>> pairwise_distance_poi_to_poi;
        pre_post_terrain_complete_graph(pre_input_file, pre_input_poi, post_input_file, post_input_poi, pairwise_distance_poi_to_poi);
    }

    void UE_N2(std::string pre_input_file, std::string pre_input_poi,
               std::string post_input_file, std::string post_input_poi,
               double epsilon)
    {
        std::vector<std::vector<double>> pairwise_distance_poi_to_poi;
        pre_post_terrain_complete_graph(pre_input_file, pre_input_poi, post_input_file, post_input_poi, pairwise_distance_poi_to_poi);
        std::unordered_map<int, double> pairwise_distance_poi_to_poi_greedy_spanner_map;

        greedy_spanner(pairwise_distance_poi_to_poi, epsilon, pairwise_distance_poi_to_poi_greedy_spanner_map);

        // for (std::unordered_map<int, double>::iterator iter = pairwise_distance_poi_to_poi_greedy_spanner_map.begin(); iter != pairwise_distance_poi_to_poi_greedy_spanner_map.end(); iter++)
        // {
        //     int a, b;
        //     hash_function_one_key_to_two_keys(pairwise_distance_poi_to_poi.size(), iter->first, a, b);
        //     std::cout << "a: " << a << ", b: " << b << ", approximate distance: " << iter->second << std::endl;
        // }

        // query
        // int x = 6;
        // int y = 2;
        // int x_y;
        // if (x > y)
        // {
        //     int temp = y;
        //     y = x;
        //     x = temp;
        // }
        // hash_function_two_keys_to_one_key(pairwise_distance_poi_to_poi.size(), x, y, x_y);
        // double distance_in_greedy_spanner = pairwise_distance_poi_to_poi_greedy_spanner_map[x_y];
        // double real_distance = pairwise_distance_poi_to_poi[x][y - x];
        // std::cout << "x: " << x << ", y: " << y << ", approximate distance: " << distance_in_greedy_spanner << ", real distance: " << real_distance << ", ratio: " << distance_in_greedy_spanner / real_distance << std::endl;
    }

    void UE(std::string pre_input_file, std::string pre_input_poi,
                std::string post_input_file, std::string post_input_poi,
                double epsilon)
    {
        std::vector<std::vector<double>> pairwise_distance_poi_to_poi;
        pre_post_terrain_complete_graph(pre_input_file, pre_input_poi, post_input_file, post_input_poi, pairwise_distance_poi_to_poi);
        std::unordered_map<int, double> pairwise_distance_poi_to_poi_greedy_spanner_map;

        clustering_greedy_spanner(pairwise_distance_poi_to_poi, epsilon, pairwise_distance_poi_to_poi_greedy_spanner_map);

        // for (std::unordered_map<int, double>::iterator iter = pairwise_distance_poi_to_poi_greedy_spanner_map.begin(); iter != pairwise_distance_poi_to_poi_greedy_spanner_map.end(); iter++)
        // {
        //     int a, b;
        //     hash_function_one_key_to_two_keys(pairwise_distance_poi_to_poi.size(), iter->first, a, b);
        //     std::cout << "a: " << a << ", b: " << b << ", approximate distance: " << iter->second << std::endl;
        // }

        // query
        // int x = 6;
        // int y = 2;
        // int x_y;
        // if (x > y)
        // {
        //     int temp = y;
        //     y = x;
        //     x = temp;
        // }
        // hash_function_two_keys_to_one_key(pairwise_distance_poi_to_poi.size(), x, y, x_y);
        // double distance_in_greedy_spanner = pairwise_distance_poi_to_poi_greedy_spanner_map[x_y];
        // double real_distance = pairwise_distance_poi_to_poi[x][y - x];
        // std::cout << "x: " << x << ", y: " << y << ", approximate distance: " << distance_in_greedy_spanner << ", real distance: " << real_distance << ", ratio: " << distance_in_greedy_spanner / real_distance << std::endl;
    }
    */


/*
              Graph g(9);
              g.add_edge_Dijkstra(0, 1, 4);
              g.add_edge_Dijkstra(0, 7, 8);
              g.add_edge_Dijkstra(1, 2, 8);
              g.add_edge_Dijkstra(1, 7, 1);
              g.add_edge_Dijkstra(2, 3, 5);
              g.add_edge_Dijkstra(2, 8, 2);
              g.add_edge_Dijkstra(2, 5, 4);
              g.add_edge_Dijkstra(3, 4, 9);
              g.add_edge_Dijkstra(3, 5, 14);
              g.add_edge_Dijkstra(4, 5, 17);
              g.add_edge_Dijkstra(5, 6, 2);
              g.add_edge_Dijkstra(6, 7, 1);
              g.add_edge_Dijkstra(6, 8, 6);
              g.add_edge_Dijkstra(7, 8, 7);
              std::vector<double> a(9, INF);

              g.shortest_path(0, a, 7);
              g.shortest_path(0, 7, a);

              for (int j = 0; j < a.size(); j++)
              {
                     std::cout << "j: " << j << ", distance: " << a[j] << std::endl;
              }

              int V = 9, E = 14;
              Graph g(V, E);

              g.add_edge_Kruskal(0, 1, 4);
              g.add_edge_Kruskal(0, 7, 8);
              g.add_edge_Kruskal(1, 2, 8);
              g.add_edge_Kruskal(1, 7, 11);
              g.add_edge_Kruskal(2, 3, 7);
              g.add_edge_Kruskal(2, 8, 2);
              g.add_edge_Kruskal(2, 5, 4);
              g.add_edge_Kruskal(3, 4, 9);
              g.add_edge_Kruskal(3, 5, 14);
              g.add_edge_Kruskal(4, 5, 10);
              g.add_edge_Kruskal(5, 6, 2);
              g.add_edge_Kruskal(6, 7, 1);
              g.add_edge_Kruskal(6, 8, 6);
              g.add_edge_Kruskal(7, 8, 7);

              std::cout << "Edges of MST are \n";
              int mst_wt = g.MST_Kruskal();
              std::cout << "Weight of MST is " << mst_wt;
              */



              /*
class ClusterNode
{
public:
    int index;
    ClusterNode *covered_by;
    std::vector<ClusterNode *> covers;
    ClusterNode()
    {
        this->covered_by = NULL;
        this->covers.clear();
    }
    ClusterNode(const int index)
    {
        this->index = index;
        this->covered_by = NULL;
        this->covers.clear();
    }
    ClusterNode(const ClusterNode &n)
    {
        this->index = n.index;
        this->covered_by = n.covered_by;
        this->covers.assign(n.covers.begin(), n.covers.end());
    }
    // the current node is covered by the parameter p
    void set_covered_by(ClusterNode *p)
    {
        this->covered_by = p;
    }
    // the parameter p covers the current node
    void set_covers(ClusterNode *p)
    {
        p->covers.push_back(this);
    }
    ~ClusterNode(){};
};
*/